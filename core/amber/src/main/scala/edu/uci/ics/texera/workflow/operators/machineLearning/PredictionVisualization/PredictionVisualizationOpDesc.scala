package edu.uci.ics.texera.workflow.operators.machineLearning.PredictionVisualization

import com.fasterxml.jackson.annotation.{JsonProperty, JsonPropertyDescription}
import com.kjetland.jackson.jsonSchema.annotations.{
  JsonSchemaInject,
  JsonSchemaString,
  JsonSchemaTitle
}
import edu.uci.ics.amber.engine.common.workflow.{InputPort, OutputPort}
import edu.uci.ics.texera.workflow.common.metadata.annotations.{
  AutofillAttributeName,
  HideAnnotation
}
import edu.uci.ics.texera.workflow.common.metadata.{OperatorGroupConstants, OperatorInfo}
import edu.uci.ics.texera.workflow.common.operators.PythonOperatorDescriptor
import edu.uci.ics.texera.workflow.common.tuple.schema.{Attribute, AttributeType, Schema}

class PredictionVisualizationOpDesc extends PythonOperatorDescriptor {

  @JsonProperty(required = true, defaultValue = "y_pred")
  @JsonSchemaTitle("Predicted Value")
  @JsonPropertyDescription("Specify the attribute generated by the model")
  @AutofillAttributeName
  var predictValue: String = "y_pred"

  @JsonProperty
  @JsonSchemaTitle("Predicted data type")
  @JsonPropertyDescription(
    "type of the predicted value"
  )
  var outputtype: AttributeType = AttributeType.STRING

  @JsonProperty(defaultValue = "false")
  @JsonSchemaTitle("Predict probability for each class")
  @JsonSchemaInject(json = """{"toggleHidden" : ["y_prob","class_number"]}""")
  var is_prob: Boolean = false

  @JsonProperty(value = "y_prob", required = false, defaultValue = "y_prob")
  @JsonSchemaTitle("Probability Column")
  @JsonPropertyDescription("Specify the predicted probability")
  @JsonSchemaInject(
    strings = Array(
      new JsonSchemaString(path = HideAnnotation.hideTarget, value = "is_prob"),
      new JsonSchemaString(path = HideAnnotation.hideType, value = HideAnnotation.Type.equals),
      new JsonSchemaString(path = HideAnnotation.hideExpectedValue, value = "false")
    )
  )
  @AutofillAttributeName
  var y_prob: String = "y_prob"

  @JsonProperty(required = true, defaultValue = "0")
  @JsonSchemaTitle("Batch Number")
  @JsonPropertyDescription("Specify the batch number")
  var k: Int = Int.box(0)

  @JsonProperty(value = "class_number", required = false, defaultValue = "2")
  @JsonSchemaTitle("Number of classes")
  @JsonPropertyDescription("Specify the number of classes")
  @JsonSchemaInject(
    strings = Array(
      new JsonSchemaString(path = HideAnnotation.hideTarget, value = "is_prob"),
      new JsonSchemaString(path = HideAnnotation.hideType, value = HideAnnotation.Type.equals),
      new JsonSchemaString(path = HideAnnotation.hideExpectedValue, value = "false")
    )
  )
  var class_number: Int = Int.box(2)

  override def operatorInfo: OperatorInfo =
    OperatorInfo(
      "Prediction Visualization",
      "Visualization for results predicted by machine learning classifier",
      OperatorGroupConstants.MODEL_VISUALIZATION_GROUP,
      inputPorts = List(InputPort()),
      outputPorts = List(OutputPort())
    )

  override def generatePythonCode(): String = {
    var flag_prob = "False"
    if (is_prob) flag_prob = "True"
    var classList = this.generateClassStrings(class_number)
    var list_class = classList.map(classes => s""""$classes"""").mkString(",")

    val finalcode =
      s"""
         |from pytexera import *
         |import numpy as np
         |import pandas as pd
         |
         |class ProcessTableOperator(UDFTableOperator):
         |
         |     @overrides
         |     def process_table(self, table: Table, port: int) -> Iterator[Optional[TableLike]]:
         |
         |
         |
         |        pred = table["$predictValue"][0]
         |        if pred.dtype=="object":
         |            head = np.array(["class"])
         |        else:
         |            head =np.array([-1])
         |
         |        pred  = pred.reshape(-1, 1)
         |        c = np.vstack((head,pred))
         |        df = pd.DataFrame(c, columns=["$predictValue"])
         |        if "Iteration" in table.columns:
         |            df["Iteration"] = float(table["Iteration"])
         |
         |        if $flag_prob:
         |            cs =table["$y_prob"][$k][1]
         |            prob =table["$y_prob"][$k][0]
         |            def add_string(x):
         |                return f'p:{x}'
         |            add_string_vectorized = np.vectorize(add_string)
         |            prob = add_string_vectorized(prob)
         |            c = np.vstack((cs,prob))
         |            cc = [$list_class]
         |            prob_df = pd.DataFrame(c, columns=cc)
         |            df = pd.concat([prob_df,df], axis=1)
         |
         |
         |        yield df
         |
         |
         |""".stripMargin
    finalcode
  }
  override def getOutputSchema(schemas: Array[Schema]): Schema = {
    val outputSchemaBuilder = Schema.builder()
    outputSchemaBuilder.add(new Attribute(predictValue, outputtype))
    if (is_prob) {
      var classList = this.generateClassStrings(class_number)
      for (className <- classList) {
        outputSchemaBuilder.add(new Attribute(className, AttributeType.STRING))
      }
    }

    outputSchemaBuilder.build()
  }
  private def generateClassStrings(classNumber: Int): List[String] = {
    (0 until classNumber).map(i => s"class$i").toList
  }

}
